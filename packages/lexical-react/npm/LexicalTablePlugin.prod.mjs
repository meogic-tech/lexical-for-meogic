/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import{useLexicalComposerContext as e}from"@lexical/react/LexicalComposerContext";import{TableNode as t,TableCellNode as o,TableRowNode as r,INSERT_TABLE_COMMAND as n,$createTableNodeWithDimensions as l,$isTableNode as s,$getNodeTriplet as a,$computeTableMap as i,$isTableRowNode as c,$isTableCellNode as d,$createTableCellNode as f,applyTableHandlers as g}from"@lexical/table";import{$insertNodeToNearestRoot as u,$insertFirst as m}from"@lexical/utils";import{$isTextNode as p,COMMAND_PRIORITY_EDITOR as h,$nodesOfType as w,$getNodeByKey as C}from"lexical";import{useEffect as x}from"react";var b=function(e){const t=new URLSearchParams;t.append("code",e);for(let e=1;e<arguments.length;e++)t.append("v",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)};function N({hasCellMerge:N=!0,hasCellBackgroundColor:S=!0,hasTabHandler:E=!0}){const[v]=e();return x((()=>(v.hasNodes([t,o,r])||b(10),v.registerCommand(n,(({columns:e,rows:t,includeHeaders:o})=>{const r=l(Number(t),Number(e),o);u(r);const n=r.getFirstDescendant();return p(n)&&n.select(),!0}),h))),[v]),x((()=>{const e=new Map,o=t=>{const o=t.getKey(),r=v.getElementByKey(o);if(r&&!e.has(o)){const n=g(t,r,v,E);e.set(o,n)}};v.getEditorState().read((()=>{const e=w(t);for(const t of e)s(t)&&o(t)}));const r=v.registerMutationListener(t,(t=>{for(const[r,n]of t)if("created"===n)v.getEditorState().read((()=>{const e=C(r);s(e)&&o(e)}));else if("destroyed"===n){const t=e.get(r);void 0!==t&&(t.removeListeners(),e.delete(r))}}));return()=>{r();for(const[,t]of e)t.removeListeners()}}),[v,E]),x((()=>{if(!N)return v.registerNodeTransform(o,(e=>{if(e.getColSpan()>1||e.getRowSpan()>1){const[,,t]=a(e),[o]=i(t,e,e),r=o.length,n=o[0].length;let l=t.getFirstChild();if(!c(l))throw Error("Expected TableNode first child to be a RowNode");const s=[];for(let e=0;e<r;e++){if(0!==e&&(l=l.getNextSibling(),!c(l)))throw Error("Expected TableNode first child to be a RowNode");let t=null;for(let r=0;r<n;r++){const n=o[e][r],a=n.cell;if(n.startRow===e&&n.startColumn===r)t=a,s.push(a);else if(a.getColSpan()>1||a.getRowSpan()>1){if(!d(a))throw Error("Expected TableNode cell to be a TableCellNode");const e=f(a.__headerState);null!==t?t.insertAfter(e):m(l,e)}}}for(const e of s)e.setColSpan(1),e.setRowSpan(1)}}))}),[v,N]),x((()=>{if(!S)return v.registerNodeTransform(o,(e=>{null!==e.getBackgroundColor()&&e.setBackgroundColor(null)}))}),[v,S,N]),null}export{N as TablePlugin};
