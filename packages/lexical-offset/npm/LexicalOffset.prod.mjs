/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import{$getNodeByKey as t,$isTextNode as e,$createRangeSelection as n,$isElementNode as l}from"lexical";var s=function(t){const e=new URLSearchParams;e.append("code",t);for(let t=1;t<arguments.length;t++)e.append("v",arguments[t]);throw Error(`Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)};class o{constructor(t,e,n=1){this._offsetMap=t,this._firstNode=e,this._blockOffsetSize=n}createSelectionFromOffsets(l,s,o){const f=this._firstNode;if(null===f)return null;let c=l,u=s,a=i(f,c,this._blockOffsetSize),d=i(f,u,this._blockOffsetSize);if(void 0!==o&&(c=r(c,a,o,this,this._blockOffsetSize),a=i(f,c,this._blockOffsetSize),u=r(u,d,o,this,this._blockOffsetSize),d=i(f,u,this._blockOffsetSize)),null===a||null===d)return null;let p=a.key,h=d.key;const g=t(p),v=t(h);if(null===g||null===v)return null;let _=0,k=0,y="element",x="element";if("text"===a.type){_=c-a.start,y="text";const t=g.getNextSibling();c!==u&&_===g.getTextContentSize()&&e(t)&&(_=0,p=t.__key)}else"inline"===a.type&&(p=g.getParentOrThrow().getKey(),_=u>a.start?a.end:a.start);"text"===d.type?(k=u-d.start,x="text"):"inline"===d.type&&(h=v.getParentOrThrow().getKey(),k=u>d.start?d.end:d.start);const S=n();return null===S?null:(S.anchor.set(p,_,y),S.focus.set(h,k,x),S)}getOffsetsFromSelection(t){const e=t.anchor,n=t.focus,l=this._offsetMap,s=e.offset,o=n.offset;let r=-1,i=-1;if("text"===e.type){const t=l.get(e.key);void 0!==t&&(r=t.start+s)}else{const t=e.getNode().getDescendantByIndex(s);if(null!==t){const e=l.get(t.getKey());if(void 0!==e){r=t.getIndexWithinParent()!==s?e.end:e.start}}}if("text"===n.type){const t=l.get(n.key);void 0!==t&&(i=t.start+n.offset)}else{const t=n.getNode().getDescendantByIndex(o);if(null!==t){const e=l.get(t.getKey());if(void 0!==e){i=t.getIndexWithinParent()!==o?e.end:e.start}}}return[r,i]}}function r(t,e,n,l,s){const o=n._offsetMap,r=l._offsetMap,f=new Set;let c=t,u=e;for(;null!==u;){const t=u.key,e=o.get(t),n=u.end-u.start;if(f.add(t),void 0===e)c+=n;else{const t=e.end-e.start;t!==n&&(c+=n-t)}const l=u.prev;if(null!==l){u=l;continue}let s=u.parent;for(;null!==s;){let t=s.prev;if(null!==t){const e=t.key,n=o.get(e),l=t.end-t.start;if(f.add(e),void 0===n)c+=l;else{const t=n.end-n.start;t!==l&&(c+=l-t)}t=t.prev}s=s.parent}break}const a=n._firstNode;if(null!==a){u=i(a,t,s);let e=!1;for(;null!==u;){if(!f.has(u.key)){e=!0;break}u=u.parent}if(!e)for(;null!==u;){const t=u.key;if(!f.has(t)){const e=r.get(t),n=u.end-u.start;if(void 0===e)c-=n;else{const t=e.end-e.start;n!==t&&(c+=t-n)}}u=u.prev}}return c}function i(t,e,n){let l=t;for(;null!==l;){if(e<l.end+("element"!==l.type||0===n?1:0)){const t=l.child;if(null!==t){l=t;continue}return l}const t=l.next;if(null===t)break;l=t}return null}function f(t,e,n,l,s,o){return{child:t,end:l,key:s,next:null,parent:o,prev:null,start:n,type:e}}function c(t,n,o,r,i,c){const d=r.get(n);void 0===d&&s(3);const p=t.offset;if(l(d)){const e=a(d,r),l=0===e.length,s=l?null:u(t,e,null,r,i,c);t.prevIsBlock&&!l||(t.prevIsBlock=!0,t.offset+=c);const h=f(s,"element",p,p,n,o);null!==s&&(s.parent=h);const g=t.offset;return h.end=g,i.set(n,h),h}t.prevIsBlock=!1;const h=e(d),g=h?d.__text.length:1,v=f(null,h?"text":"inline",p,t.offset+=g,n,o);return i.set(n,v),v}function u(t,e,n,l,s,o){let r=null,i=null;const f=e.length;for(let u=0;u<f;u++){const f=c(t,e[u],n,l,s,o);null===i?r=f:(f.prev=i,i.next=f),i=f}return r}function a(e,n){const l=[];let o=e.__first;for(;null!==o;){const e=null===n?t(o):n.get(o);null==e&&s(101),l.push(o),o=e.__next}return l}function d(t,e=1,n){const l=(n||t._pendingEditorState||t._editorState)._nodeMap,s=l.get("root"),r=new Map,i=u({offset:0,prevIsBlock:!1},a(s,l),null,l,r,e);return new o(r,i,e)}export{d as $createOffsetView,o as OffsetView,a as createChildrenArray};
