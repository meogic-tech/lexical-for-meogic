/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import{$getRoot as t,$isDecoratorNode as e,$isElementNode as n,$isParagraphNode as r,$isTextNode as i,TextNode as o,$createTextNode as l}from"lexical";function s(){return t().getTextContent()}function u(t,e=!0){if(t)return!1;let n=s();return e&&(n=n.trim()),""===n}function f(t,e){return()=>u(t,e)}function c(o){if(!u(o,!1))return!1;const l=t().getChildren(),s=l.length;if(s>1)return!1;for(let t=0;t<s;t++){const o=l[t];if(e(o))return!1;if(n(o)){if(!r(o))return!1;if(0!==o.__indent)return!1;const e=o.getChildren(),n=e.length;for(let r=0;r<n;r++){const n=e[t];if(!i(n))return!1}}}return!0}function g(t){return()=>c(t)}function x(t,e){let r=t.getFirstChild(),o=0;t:for(;null!==r;){if(n(r)){const t=r.getFirstChild();if(null!==t){r=t;continue}}else if(i(r)){const t=r.getTextContentSize();if(o+t>e)return{node:r,offset:e-o};o+=t}const t=r.getNextSibling();if(null!==t){r=t;continue}let l=r.getParent();for(;null!==l;){const t=l.getNextSibling();if(null!==t){r=t;continue t}l=l.getParent()}break}return null}function a(t,e,n,r){const s=t=>t instanceof n,u=t=>{const e=l(t.getTextContent());e.setFormat(t.getFormat()),t.replace(e)};return[t.registerNodeTransform(o,(t=>{if(!t.isSimpleText())return;const n=t.getPreviousSibling();let o,l=t.getTextContent(),f=t;if(i(n)){const r=n.getTextContent(),i=e(r+l);if(s(n)){if(null===i||0!==(t=>t.getLatest().__mode)(n))return void u(n);{const e=i.end-r.length;if(e>0){const i=r+l.slice(0,e);if(n.select(),n.setTextContent(i),e===l.length)t.remove();else{const n=l.slice(e);t.setTextContent(n)}return}}}else if(null===i||i.start<r.length)return}for(;;){o=e(l);let t,c=null===o?"":l.slice(o.end);if(l=c,""===c){const t=f.getNextSibling();if(i(t)){c=f.getTextContent()+t.getTextContent();const n=e(c);if(null===n)return void(s(t)?u(t):t.markDirty());if(0!==n.start)return}}else{const t=e(c);if(null!==t&&0===t.start)return}if(null===o)return;if(0===o.start&&i(n)&&n.isTextEntity())continue;0===o.start?[t,f]=f.splitText(o.end):[,t,f]=f.splitText(o.start,o.end);const g=r(t);if(g.setFormat(t.getFormat()),t.replace(g),null==f)return}})),t.registerNodeTransform(n,(t=>{const n=t.getTextContent(),r=e(n);if(null===r||0!==r.start)return void u(t);if(n.length>r.end)return void t.splitText(r.end);const o=t.getPreviousSibling();i(o)&&o.isTextEntity()&&(u(o),u(t));const l=t.getNextSibling();i(l)&&l.isTextEntity()&&(u(l),s(t)&&u(t))}))]}export{c as $canShowPlaceholder,g as $canShowPlaceholderCurry,x as $findTextIntersectionFromCharacters,u as $isRootTextContentEmpty,f as $isRootTextContentEmptyCurry,s as $rootTextContent,a as registerLexicalTextEntity};
